---
title: 图论基础
top_img: false
date: 2022-12-15 21:59:38
tags:
- 图论
categories:
- 信息学
- 笔记
---
{% note flat info %}
这里放了最基础的图论内容  
在本文中`maxn`为最大点数，`maxm`为最大边数.
{% endnote %}
# 链式前向星
邻接矩阵太sb了，不放了。
其实在数据较小**或考试时间不够**时可以用`vector`，支持`auto`，特别方便。
{% note flat info %}
以下代码存图所用链式前向星皆用这个模板
{% endnote %}
```c++
struct edg
{
	int next,to,w;
}edge[maxm];//无向图是这里要<<1
int head[maxn],cnt=1;
inline void getin(int a,int b,int w)//加边
{
	edge[cnt]=(edg){head[a],b,w};
	head[a]=cnt++;
}
for(int j=head[tmp];j;j=edge[j].next)//访问tmp发出的边
```
# 拓扑排序
在建边时先预处理入度，即代码中的`vin`
```c++
int vin[maxn];//这个vin

queue<int>que;
for(int i=1;i<=n;i++)
if(!vin[i])
que.emplace(i);
while(!que.empty())
{
	int dc=que.front();
	for(int j=head[dc];j;j=edge[j].next)
	if(!(--vin[edge[j].to]))
	que.emplace(edge[j].to);
}
```
# 最短路
## floyd
注意到最外层枚举的是**中转点**
```c++
int dis[maxn][maxn];//dis是邻接矩阵
for(int k=1;k<=n;k++)//k在这里！！
    for(int i=1;i<=n;i++)
        for(int j=1;j<=n;j++)
        if(dis[i][j]>dis[i][k]+dis[k][j])
        {
            dis[i][j]=dis[i][k]+dis[k][j];
        }
```
## dijkstra
> 论某个傻瓜曾经还在用手写堆
```c++
struct node
{
	int no,num;
	bool operator<(node y)const
	{
		return num>y.num;
	}
};
int dis[maxn];
bool bl[maxn];
void dijkstra(int s)
{
	memset(dis,0x3f,sizeof dis);
	memset(bl,0,sizeof bl);
	priority_queue<node>que;
	dis[s]=0;
	que.emplace((node){s,0});
	while(!que.empty())
	{
		int dc=que.top().no;
		que.pop();
		if(bl[dc])continue;
		bl[dc]=true;
		for(register int j=head[dc];j;j=edge[j].next)
		if(dis[edge[j].to]>edge[j].w+dis[dc])
		{
			dis[edge[j].to]=edge[j].w+dis[dc];
			if(!bl[edge[j].to])que.emplace((node){edge[j].to,dis[edge[j].to]});
		}
	}
}
```
## spfa+负环判断
```c++
int dis[maxn],tme[maxn];
bool bl[maxn];
bool spfa(int s)//返回s出发是否到达负环,可以返回false,代表不合法
{
	memset(dis,0x3f,sizeof dis);
	memset(bl,0,sizeof bl);
	memset(tme,0,sizeof tme);
	queue<int>que;
	que.emplace(s);
	bl[s]=true;dis[s]=0;
	while(!que.empty())
	{
		int dc=que.front();
		bl[dc]=false;que.pop();
		for(register int j=head[dc];j;j=edge[j].next)
		if(dis[edge[j].to]>dis[dc]+edge[j].w)
		{
			dis[edge[j].to]=dis[dc]+edge[j].w;
			tme[edge[j].to]=tme[dc]+1;
			if(tme[edge[j].to]>=n)return false;
			if(!bl[edge[j].to])que.emplace(edge[j].to),bl[edge[j].to]=true;
		}
	}
	return true;
}
```
## 0-1bfs
很不错的例题:[P1948 [USACO08JAN]Telephone Lines S](https://www.luogu.com.cn/problem/P1948)
```c++
bool bl[maxn];
int dis[maxn];
void bfs_01(int s)
{
	memset(dis,0x3f,sizeof dis);
	memset(bl,0,sizeof bl);
	deque<int>que;
	dis[s]=0;
	bl[s]=true;
	que.push_back(s);
	while(!que.empty())
	{
		int dc=que.front();
		que.pop_front();
		for(register int j=head[dc];j;j=edge[j].next)
		{
		if(dis[edge[j].to]>dis[dc]+edge[j].w)
		{
			dis[edge[j].to]=dis[dc]+edge[j].w;
			if(!bl[edge[j].to])
			if(edge[j].w)que.push_back(edge[j].to);
			else que.push_front(edge[j].to);
		}	
		}
	}
}
```
## 关于DAG
显然，在DAG中，无论权值是否为负，比一个点拓扑序小的点全松弛完毕后，这个点的最短路就求出来了（因为显然每个点都只能从比自己拓扑序小的点走到）。
+ 代码几乎和拓扑排序一模一样，不放了。
# 联通性
## tarjan(有向图缩点)
```c++
int tj,tdfs,bel[maxn],low[maxn],dfn[maxn],sta[maxn],tot;
bool insta[maxn],bl[maxn];
void tarjan(int dc)
{
	sta[++tot]=dc;insta[dc]=bl[dc]=true;
	dfn[dc]=low[dc]=++tdfs;
	for(register int j=head[dc];j;j=edge[j].next)
	if(!dfn[edge[j].to])
	{tarjan(edge[j].to);low[dc]=min(low[dc],low[edge[j].to]);}
	else
	if(insta[edge[j].to])
	low[dc]=min(low[dc],dfn[edge[j].to]);
	if(low[dc]==dfn[dc])
	{
		bel[dc]=++tj;
		while(1)
		{
			bel[sta[tot]]=tj;
			insta[sta[tot]]=false;
			tot--;
			if(sta[tot+1]==dc)break;
		}
	}
}
```