---
swiper_index: -1
swiper_desc: 算法总目录
title: 所有笔记的索引
date: 2022-11-21 22:18:45
tags:
- 算法与数据结构
categories:
- 信息学
- 笔记
top_img: /img/cool.jpg
cover: /img/altcover_0.jpg
---
> 以下代码编译环境>=c++11  
> ~~学校的电脑git都安装不了，博客只能在家更新了，悲:sob:~~
+ [关于DAG](#关于dag)
# 数据结构
## 线段树
+ 加和乘的模板，`maxn`为最大数组大小。
```c++
ll tre[maxn<<2],add[maxn<<2],pro[maxn<<2];//tre区间和 add和标记 pro积标记 
void build(int k,int l,int r)
{
	pro[k]=1;
	if(l==r)
	{
		tre[k]=nl[l];//nl:原数组
		return ;
	}
	int mid=(l+r)>>1;
	build(k<<1,l,mid);
	build(k<<1|1,mid+1,r);
	tre[k]=(tre[k<<1]+tre[k<<1|1])%mod;
}
inline void up(int dc,int k,ll lin,ll x)//dc: 1=一级(+) 2=二级(*)
{
	if(dc==1)
	{
		(tre[k]+=x*lin)%=mod;
		(add[k]+=x)%=mod;
	}
	else
	{
		(tre[k]*=x)%=mod;
		(add[k]*=x)%=mod;
		(pro[k]*=x)%=mod;
	}
}
inline void pushdown(int k,int l,int r,int mid)
{
	if(pro[k]^1)
	{
		up(2,k<<1,mid-l+1,pro[k]);
		up(2,k<<1|1,r-mid,pro[k]);
		pro[k]=1;
	}
	if(add[k]^0)
	{
		up(1,k<<1,mid-l+1,add[k]);
		up(1,k<<1|1,r-mid,add[k]);
		add[k]=0;
	}
}
int dcl,dcr;
ll num;
void update(int dc,int k,int l,int r)
{
	if(dcr<l||r<dcl)return ;
	if(dcl<=l&&r<=dcr)
	{
		up(dc,k,r-l+1,num);
		return ;
	}
	int mid=(l+r)>>1;
	pushdown(k,l,r,mid);
	update(dc,k<<1,l,mid);
	update(dc,k<<1|1,mid+1,r);
	tre[k]=tre[k<<1]+tre[k<<1|1];
}
ll getans(int k,int l,int r)
{
	if(dcr<l||r<dcl)return 0;
	if(dcl<=l&&r<=dcr)
	{
		return tre[k];
	}
	int mid=(l+r)>>1;
	pushdown(k,l,r,mid);
	return (getans(k<<1,l,mid)+getans(k<<1|1,mid+1,r))%mod;
}
```
# 图论
+ 在本块中`maxn`为最大点数，`maxm`为最大边数.
## 链式前向星
+ 其实在数据较小**或考试时间不够**时可以用`vector`，支持`auto`，特别方便。
+ 以下代码存图所用链式前向星皆用这个模板
```c++
struct edg
{
	int next,to,w;
}edge[maxm];//无向图是这里要<<1
int head[maxn],cnt=1;
inline void getin(int a,int b,int w)//加边
{
	edge[cnt]=(edg){head[a],b,w};
	head[a]=cnt++;
}
for(int j=head[tmp];j;j=edge[j].next)//访问tmp发出的边
```
## 拓扑排序
+ 在建边时先预处理入度，即代码中的`vin`
```c++
int vin[maxn];//这个vin

queue<int>que;
for(int i=1;i<=n;i++)
if(!vin[i])
que.emplace(i);
while(!que.empty())
{
	int dc=que.front();
	for(int j=head[dc];j;j=edge[j].next)
	if(!(--vin[edge[j].to]))
	que.emplace(edge[j].to);
}
```
## 最短路
### dijkstra
> 论某个傻瓜曾经还在用手写堆
```c++
struct node
{
	int no,num;
	bool operator<(node y)const
	{
		return num>y.num;
	}
};
int dis[maxn];
bool bl[maxn];
void dijkstra(int s)
{
	memset(dis,0x3f,sizeof dis);
	memset(bl,0,sizeof bl);
	priority_queue<node>que;
	dis[s]=0;
	que.emplace((node){s,0});
	while(!que.empty())
	{
		int dc=que.top().no;
		que.pop();
		if(bl[dc])continue;
		bl[dc]=true;
		for(register int j=head[dc];j;j=edge[j].next)
		if(dis[edge[j].to]>edge[j].w+dis[dc])
		{
			dis[edge[j].to]=edge[j].w+dis[dc];
			if(!bl[edge[j].to])que.emplace((node){edge[j].to,dis[edge[j].to]});
		}
	}
}
```
### spfa+负环判断
```c++
int dis[maxn],tme[maxn];
bool bl[maxn];
bool spfa(int s)//返回s出发是否到达负环,可以返回false,代表不合法
{
	memset(dis,0x3f,sizeof dis);
	memset(bl,0,sizeof bl);
	memset(tme,0,sizeof tme);
	queue<int>que;
	que.emplace(s);
	bl[s]=true;dis[s]=0;
	while(!que.empty())
	{
		int dc=que.front();
		bl[dc]=false;que.pop();
		for(register int j=head[dc];j;j=edge[j].next)
		if(dis[edge[j].to]>dis[dc]+edge[j].w)
		{
			dis[edge[j].to]=dis[dc]+edge[j].w;
			tme[edge[j].to]=tme[dc]+1;
			if(tme[edge[j].to]>=n)return false;
			if(!bl[edge[j].to])que.emplace(edge[j].to),bl[edge[j].to]=true;
		}
	}
	return true;
}
```
### 0-1bfs
+ 很不错的例题:[P1948 [USACO08JAN]Telephone Lines S](https://www.luogu.com.cn/problem/P1948)
```c++
bool bl[maxn];
int dis[maxn];
void bfs_01(int s)
{
	memset(dis,0x3f,sizeof dis);
	memset(bl,0,sizeof bl);
	deque<int>que;
	dis[s]=0;
	bl[s]=true;
	que.push_back(s);
	while(!que.empty())
	{
		int dc=que.front();
		que.pop_front();
		for(register int j=head[dc];j;j=edge[j].next)
		{
		if(dis[edge[j].to]>dis[dc]+edge[j].w)
		{
			dis[edge[j].to]=dis[dc]+edge[j].w;
			if(!bl[edge[j].to])
			if(edge[j].w)que.push_back(edge[j].to);
			else que.push_front(edge[j].to);
		}	
		}
	}
}
```
### 关于DAG
+ 显然，在DAG中，无论权值是否为负，比一个点拓扑序小的点全松弛完毕后，这个点的最短路就求出来了（因为显然每个点都只能从比自己拓扑序小的点走到）。
+ 代码几乎和拓扑排序一模一样，不放了。
## 联通性
### tarjan(有向图)
```c++
int tj,tdfs,bel[maxn],low[maxn],dfn[maxn],sta[maxn],tot;
bool insta[maxn],bl[maxn];
void tarjan(int dc)
{
	sta[++tot]=dc;insta[dc]=bl[dc]=true;
	dfn[dc]=low[dc]=++tdfs;
	for(register int j=head[dc];j;j=edge[j].next)
	if(!dfn[edge[j].to])
	{tarjan(edge[j].to);low[dc]=min(low[dc],low[edge[j].to]);}
	else
	if(insta[edge[j].to])
	low[dc]=min(low[dc],dfn[edge[j].to]);
	if(low[dc]==dfn[dc])
	{
		bel[dc]=++tj;
		while(1)
		{
			bel[sta[tot]]=tj;
			insta[sta[tot]]=false;
			tot--;
			if(sta[tot+1]==dc)break;
		}
	}
}
```