---
title: 数据杰构
top_img: false
date: 2023-04-08 11:36:18
tags:
- 数据结构
categories:
- 信息学
- 笔记
---
{% note flat info %}
板子
{% endnote %}
# 线段树
乘和加。
```c++
int n,m,nl[maxn];
ll mod;
ll tre[maxn<<2],add[maxn<<2],pro[maxn<<2];
void build(int k,int l,int r)
{
	pro[k]=1;
	if(l==r)
	{
		tre[k]=nl[l];
		return ;
	}
	int mid=(l+r)>>1;
	build(k<<1,l,mid);
	build(k<<1|1,mid+1,r);
	tre[k]=(tre[k<<1]+tre[k<<1|1])%mod;
}
inline void up(int dc,int k,ll lin,ll x)
{
	if(dc==1)
	{
		(tre[k]+=x*lin)%=mod;
		(add[k]+=x)%=mod;
	}
	else
	{
		(tre[k]*=x)%=mod;
		(add[k]*=x)%=mod;
		(pro[k]*=x)%=mod;
	}
}
inline void pushdown(int k,int l,int r,int mid)
{
	if(pro[k]^1)
	{
		up(2,k<<1,mid-l+1,pro[k]);
		up(2,k<<1|1,r-mid,pro[k]);
		pro[k]=1;
	}
	if(add[k]^0)
	{
		up(1,k<<1,mid-l+1,add[k]);
		up(1,k<<1|1,r-mid,add[k]);
		add[k]=0;
	}
}
int dcl,dcr;
ll num;
void update(int dc,int k,int l,int r)
{
	if(dcr<l||r<dcl)return ;
	if(dcl<=l&&r<=dcr)
	{
		up(dc,k,r-l+1,num);
		return ;
	}
	int mid=(l+r)>>1;
	pushdown(k,l,r,mid);
	update(dc,k<<1,l,mid);
	update(dc,k<<1|1,mid+1,r);
	tre[k]=tre[k<<1]+tre[k<<1|1];
}
ll getans(int k,int l,int r)
{
	if(dcr<l||r<dcl)return 0;
	if(dcl<=l&&r<=dcr)
	{
		return tre[k];
	}
	int mid=(l+r)>>1;
	pushdown(k,l,r,mid);
	return (getans(k<<1,l,mid)+getans(k<<1|1,mid+1,r))%mod;
}
```
# 树状数组
修改单点以及求前缀和。
```c++
int nl[maxn],k,a,b;
int n,m;
void upd(int a,int b)
{
	for(;a<=n;a+=a&(-a))
	{
		nl[a]+=b;
	}
	return ;
}
int getas(int x)
{
	int ans=0;
	for(;x>=1;x-=x&(-x))
	{
		ans+=nl[x];
	}
	return ans;
}
```