---
title: 树上背包上下界优化
top_img: false
date: 2023-03-21 20:27:57
tags:
- 动态规划
- 背包
categories:
- 信息学
- 笔记
---
{% note flat info %}
看到一个比较牛（sao1）的复杂度证明，记一下。
{% endnote %}
树形背包的复杂度是 $O(nm^2)$，比起平时背包的 $O(nm)$ 差多了去了。

但树形背包真的可以 $O(nm)$

以[这题](https://www.luogu.com.cn/problem/P2014)为例（此题花费都是1，差评）。
核心代码（优化后）：
```c++
#define fru(i,j,k) for(register int i=j;i<=k;i++)//for_register_up
#define frd(i,j,k) for(register int i=j;i>=k;i--)//for_register_down
void dp(int dc)
{
	siz[dc]=1;
	for(register int i=head[dc];i!=0;i=dot[i].next)
	{
		dp(dot[i].to);
		siz[dc]+=siz[dot[i].to];
		frd(j,min(siz[dc],m),1)fru(k,0,min(j-1,siz[dot[i].to]))
		f[dc][j]=max(f[dc][j],f[dot[i].to][k]+f[dc][j-k]);
	}
	return ;
}
```

递归，在访问完每个子树时求解。设 $i$ 点花费为 $v_i$，收益为 $w_i$，$siz_i$ 表示点 $i$ 在访问到当前子树时**所有访问过的字树**的价格和与点 $i$ 的和，$f_{i,j}$ 为点 $i$ 中给 $j$ 点“价值”时的最大收益。在普通DP式 $f_{u,j}=\max{f_{i,j},f_{i,j-k-v_i}+f_{v,k}+w_i}$ 的基础上添加限制 $j\leqslant{siz_u},k\leqslant{siz_v}$即可。  

# 证明
每次合并一棵子树时付出的代价是”已经合并的兄弟子树的大小之和”*”正在合并的这棵子树的大小”,实质上是树上每对节点在LCA处贡献时间复杂度。

# 后话
虽然就5个点，还是比$O(nm^2)$快不少。
![评测结果](https://s2.loli.net/2023/03/21/m1NEpMwSBtZqAa5.png)