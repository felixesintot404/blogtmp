---
title: 树上背包上下界优化
top_img: false
date: 2023-03-21 20:27:57
tags:
- 动态规划
- 背包
categories:
- 信息学
- 笔记
---
{% note flat info %}
看到一个比较牛（sao）的复杂度证明，记一下。
{% endnote %}
树形背包的复杂度是 $O(nm^2)$，比起平时背包的 $O(nm)$ 差多了去了。

但树形背包真的可以 $O(nm)$

以[这题](https://www.luogu.com.cn/problem/P2014)为例（此题花费都是1，差评）。
核心代码（优化后，选自OIWIKI）：
```c++
int dfs(int u) {
  int p = 1;
  f[u][1] = s[u];
  for (auto v : e[u]) {
    int siz = dfs(v);
    // 注意下面两重循环的上界和下界
    // 只考虑已经合并过的子树，以及选的课程数超过 m+1 的状态没有意义
    for (int i = min(p, m + 1); i; i--)
      for (int j = 1; j <= siz && i + j <= m + 1; j++)
        f[u][i + j] = max(f[u][i + j], f[u][i] + f[v][j]);  // 转移方程
    p += siz;
  }
  return p;
}
```

递归，在访问完每个子树时求解。设 $i$ 点花费为 $v_i$，收益为 $w_i$，$siz_i$ 表示点 $i$ 在访问到当前子树时**所有访问过的字树**的价格和与点 $i$ 的和，$f_{i,j}$ 为点 $i$ 中给 $j$ 点“价值”时的最大收益。在普通DP式 $f_{u,j}=\max{f_{i,j},f_{i,j-k-v_i}+f_{v,k}+w_i}$ 的基础上添加限制 $j\leqslant{siz_u},k\leqslant{siz_v}$ 即可。  

# 证明
每次合并一棵子树时付出的代价是”已经合并的兄弟子树的大小之和”*”正在合并的这棵子树的大小”,实质上是树上每对节点在LCA处贡献时间复杂度。

# 后话
虽然就5个点，还是比$O(nm^2)$快不少。
![评测结果](https://s2.loli.net/2023/03/21/m1NEpMwSBtZqAa5.png)