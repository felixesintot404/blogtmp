---
title: 一些板子
date: 2022-11-21 22:18:45
tags:
- 算法与数据结构
categories:
- 信息学
- 笔记
top_img: /img/cool.jpg
cover: /img/altcover_1.jpg
---
# 这是啥
> 我写的一些算法模板，主要是给自己用，封装都没封装过
# 线段树
+ 人给写麻了。
```c++
ll tre[maxn<<2],add[maxn<<2],pro[maxn<<2];//tre区间和 add和标记 pro积标记
void build(int k,int l,int r)
{
	pro[k]=1;
	if(l==r)
	{
		tre[k]=nl[l];//nl:原数组
		return ;
	}
	int mid=(l+r)>>1;
	build(k<<1,l,mid);
	build(k<<1|1,mid+1,r);
	tre[k]=(tre[k<<1]+tre[k<<1|1])%mod;
}
inline void up(int dc,int k,ll lin,ll x)//dc: 1=一级(+) 2=二级(*)
{
	if(dc==1)
	{
		(tre[k]+=x*lin)%=mod;
		(add[k]+=x)%=mod;
	}
	else
	{
		(tre[k]*=x)%=mod;
		(add[k]*=x)%=mod;
		(pro[k]*=x)%=mod;
	}
}
inline void pushdown(int k,int l,int r,int mid)
{
	if(pro[k]^1)
	{
		up(2,k<<1,mid-l+1,pro[k]);
		up(2,k<<1|1,r-mid,pro[k]);
		pro[k]=1;
	}
	if(add[k]^0)
	{
		up(1,k<<1,mid-l+1,add[k]);
		up(1,k<<1|1,r-mid,add[k]);
		add[k]=0;
	}
}
int dcl,dcr;
ll num;
void update(int dc,int k,int l,int r)
{
	if(dcr<l||r<dcl)return ;
	if(dcl<=l&&r<=dcr)
	{
		up(dc,k,r-l+1,num);
		return ;
	}
	int mid=(l+r)>>1;
	pushdown(k,l,r,mid);
	update(dc,k<<1,l,mid);
	update(dc,k<<1|1,mid+1,r);
	tre[k]=tre[k<<1]+tre[k<<1|1];
}
ll getans(int k,int l,int r)
{
	if(dcr<l||r<dcl)return 0;
	if(dcl<=l&&r<=dcr)
	{
		return tre[k];
	}
	int mid=(l+r)>>1;
	pushdown(k,l,r,mid);
	return (getans(k<<1,l,mid)+getans(k<<1|1,mid+1,r))%mod;
}
```