---
swiper_index: -1
swiper_desc: 部分基础算法的模板
title: 一些板子
date: 2022-11-21 22:18:45
tags:
- 算法与数据结构
categories:
- 信息学
- 笔记
top_img: /img/cool.jpg
cover: /img/altcover_0.jpg
---
# 这是啥
> 我写的一些较基础算法模板，主要是给自己用，封装都没封装过  
> 学校的电脑git都安装不了，博客只能在家更新了，悲:sob:  
# 线段树
```c++
ll tre[maxn<<2],add[maxn<<2],pro[maxn<<2];//tre区间和 add和标记 pro积标记
void build(int k,int l,int r)
{
	pro[k]=1;
	if(l==r)
	{
		tre[k]=nl[l];//nl:原数组
		return ;
	}
	int mid=(l+r)>>1;
	build(k<<1,l,mid);
	build(k<<1|1,mid+1,r);
	tre[k]=(tre[k<<1]+tre[k<<1|1])%mod;
}
inline void up(int dc,int k,ll lin,ll x)//dc: 1=一级(+) 2=二级(*)
{
	if(dc==1)
	{
		(tre[k]+=x*lin)%=mod;
		(add[k]+=x)%=mod;
	}
	else
	{
		(tre[k]*=x)%=mod;
		(add[k]*=x)%=mod;
		(pro[k]*=x)%=mod;
	}
}
inline void pushdown(int k,int l,int r,int mid)
{
	if(pro[k]^1)
	{
		up(2,k<<1,mid-l+1,pro[k]);
		up(2,k<<1|1,r-mid,pro[k]);
		pro[k]=1;
	}
	if(add[k]^0)
	{
		up(1,k<<1,mid-l+1,add[k]);
		up(1,k<<1|1,r-mid,add[k]);
		add[k]=0;
	}
}
int dcl,dcr;
ll num;
void update(int dc,int k,int l,int r)
{
	if(dcr<l||r<dcl)return ;
	if(dcl<=l&&r<=dcr)
	{
		up(dc,k,r-l+1,num);
		return ;
	}
	int mid=(l+r)>>1;
	pushdown(k,l,r,mid);
	update(dc,k<<1,l,mid);
	update(dc,k<<1|1,mid+1,r);
	tre[k]=tre[k<<1]+tre[k<<1|1];
}
ll getans(int k,int l,int r)
{
	if(dcr<l||r<dcl)return 0;
	if(dcl<=l&&r<=dcr)
	{
		return tre[k];
	}
	int mid=(l+r)>>1;
	pushdown(k,l,r,mid);
	return (getans(k<<1,l,mid)+getans(k<<1|1,mid+1,r))%mod;
}
```
# 图论
## 链式前向星
```c++
struct edg
{
	int next,to,w;
}edge[maxm];//无向图是这里要<<1
int head[maxn],cnt=1;
inline void getin(int a,int b,int w)
{
	edge[cnt]=(edg){head[a],b,w};
	head[a]=cnt++;
}
```
## 最短路
### dijkstra
> 论某个傻瓜曾经还在用手写堆
```c++
struct node
{
	int no,num;
	bool operator<(node y)const
	{
		return num>y.num;
	}
};
int dis[maxn];
bool bl[maxn];
void dijkstra(int s)
{
	memset(dis,0x3f,sizeof dis);
	memset(bl,0,sizeof bl);
	priority_queue<node>que;
	dis[s]=0;
	que.emplace((node){s,0});
	while(!que.empty())
	{
		int dc=que.top().no;
		que.pop();
		if(bl[dc])continue;
		bl[dc]=true;
		for(register int j=head[dc];j;j=edge[j].next)
		if(dis[edge[j].to]>edge[j].w+dis[dc])
		{
			dis[edge[j].to]=edge[j].w+dis[dc];
			if(!bl[edge[j].to])que.emplace((node){edge[j].to,dis[edge[j].to]});
		}
	}
}
```
### spfa+负环判断
```c++
int dis[maxn],tme[maxn];
bool bl[maxn];
bool spfa(int s)//返回s出发是否到达负环,可以返回false,代表不合法
{
	memset(dis,0x3f,sizeof dis);
	memset(bl,0,sizeof bl);
	memset(tme,0,sizeof tme);
	queue<int>que;
	que.emplace(s);
	bl[s]=true;dis[s]=0;
	while(!que.empty())
	{
		int dc=que.front();
		bl[dc]=false;que.pop();
		for(register int j=head[dc];j;j=edge[j].next)
		if(dis[edge[j].to]>dis[dc]+edge[j].w)
		{
			dis[edge[j].to]=dis[dc]+edge[j].w;
			tme[edge[j].to]=tme[dc]+1;
			if(tme[edge[j].to]>=n)return false;
			if(!bl[edge[j].to])que.emplace(edge[j].to),bl[edge[j].to]=true;
		}
	}
	return true;
}
```
### 0-1bfs
+ 很不错的例题:[P1948 [USACO08JAN]Telephone Lines S](https://www.luogu.com.cn/problem/P1948)
```c++
bool bl[maxn];
int dis[maxn];
void bfs_01(int s)
{
	memset(dis,0x3f,sizeof dis);
	memset(bl,0,sizeof bl);
	deque<int>que;
	dis[s]=0;
	bl[s]=true;
	que.push_back(s);
	while(!que.empty())
	{
		int dc=que.front();
		que.pop_front();
		for(register int j=head[dc];j;j=edge[j].next)
		{
		if(dis[edge[j].to]>dis[dc]+edge[j].w)
		{
			dis[edge[j].to]=dis[dc]+edge[j].w;
			if(!bl[edge[j].to])
			if(edge[j].w)que.push_back(edge[j].to);
			else que.push_front(edge[j].to);
		}	
		}
	}
}
```
## 联通性
### tarjan(有向图)
```c++
int tj,tdfs,bel[maxn],low[maxn],dfn[maxn],sta[maxn],tot;
bool insta[maxn],bl[maxn];
void tarjan(int dc)
{
	sta[++tot]=dc;insta[dc]=bl[dc]=true;
	dfn[dc]=low[dc]=++tdfs;
	for(register int j=head[dc];j;j=edge[j].next)
	if(!dfn[edge[j].to])
	{tarjan(edge[j].to);low[dc]=min(low[dc],low[edge[j].to]);}
	else
	if(insta[edge[j].to])
	low[dc]=min(low[dc],dfn[edge[j].to]);
	if(low[dc]==dfn[dc])
	{
		bel[dc]=++tj;
		while(1)
		{
			bel[sta[tot]]=tj;
			insta[sta[tot]]=false;
			tot--;
			if(sta[tot+1]==dc)break;
		}
	}
}
```