---
abbrlink: ''
categories:
- - 笔记
date: '2023-06-08T22:38:00.825569+08:00'
tags:
- 重要模板
- 数论
title: 数论模板
top_img: false
updated: 2023-7-25T11:11:57.491+8:0
---
# 知识&结论

欧拉函数：$\varphi(x)$ 表示 $\leqslant{x}$ 且与 $x$ 互质的正整数个数，如：$\varphi(1)=1$，$\varphi(p)=p-1$。

# 快速幂&取余运算

$O(\log_2{b})$ 求 $a^b \operatorname{mod} p$。

```c++
ll poww(ll a,ll b,ll p)
{
    ll ans=1;
    while(b)
    {
        if(b&1)ans=(ans*a)%p;
        a=(a*a)%p;
        b>>=1;
    }
    return ans;
}
```

# 线性筛（欧拉筛）

埃氏筛时间复杂度为 $O(n\log\log{n})$，线性筛为 $O(n)$。

```c++
bool p[/*值域*/];
int prime[/*值域*/>>1],tot,n;
inline void getprime(void)
{
    p[1]=true;
    for(int i=2;i<=n;i++)
    {
        if(!p[i])prime[++tot]=i;
        for(int j=1;j<=tot&&prime[j]*i<=n;j++)
        {
        	p[prime[j]*i]=true;
        	if(i%prime[j]==0)break;
    	}
    }
}
```

# GCD（最大公约数）

递归版：

```c++
int gcd(int a,int b)
{
	return b?gcd(b,a%b):a;
}
```

非递归版：

```c++
int gcd(int a,int b)
{
	int tm;
	while(b)
	{
		tm=a%b;
		a=b;
		b=tm;
	}
	return a;
}
```

# FFT/虚数

最后的代码真的只有FFT算子本身，思维过程一点没有😭 。

计算矩阵（这里设 $0\leqslant{i,j}\leqslant{n-1}$）：

DFT：$A_{i,j}=W_n^{ij}$

IDFT：$A_{i,j}=\cfrac{-W_n^{ij}}n$

注意运算前一定要把 $n$ 补成 $2^k$ 的形式。

```c++
//虚数类
struct cpl
{
    double a,b;
    cpl operator+(cpl y)
    {
        return (cpl){a+y.a,b+y.b};
    }
    cpl operator-(cpl y)
    {
        return (cpl){a-y.a,b-y.b};
    }
    cpl operator*(cpl y)
    {
        return (cpl){a*y.a-b*y.b,b*y.a+a*y.b};
    }
};
//FFT函数
int v[maxn];
void fft(cpl cl[],int len,bool ck)
{
    int lt=(1<<len);
    fru(i,0,lt-1)
    {
        v[i]=v[i>>1]>>1;
        if(i&1)
        {
            v[i]|=(lt>>1);
        }
        if(v[i]>i)swap(cl[i],cl[v[i]]);
    }
    cpl w,w1,T1,T2;
    for(register int i=1;i<lt;i<<=1)
    {
        w1=ck?(cpl){cos(-2.0*pi/(i<<1)),sin(-2.0*pi/(i<<1))}:(cpl){cos(2.0*pi/(i<<1)),sin(2.0*pi/(i<<1))};
        for(register int j=0;j<lt;j+=(i<<1))
        {
            w=(cpl){1,0};
            for(register int k=j;k<i+j;k++)
            {
                // cout<<k<<' '<<k+i<<endl;
                T1=cl[k]+(w*cl[k+i]);
                T2=cl[k]-(w*cl[k+i]);
                cl[k]=T1;cl[k+i]=T2;
                w=w*w1;
            }
        }
    }
    if(ck)fru(i,0,lt-1)cl[i].a/=lt;
}
```
